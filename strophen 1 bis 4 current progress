from manim import *
import math

class Constram(Scene):
    def construct(self):
        
        self.camera.background_color = WHITE
        TXTCOL = BLACK
        AMCOL = ORANGE
        GMCOL = GREEN_D
        QMCOL = BLUE_D
        HMCOL = PURPLE_D
        ACOL = RED
        BCOL = DARK_BLUE
        RIGHTANGLECOL = GREY
        r = 3
        
        # Punkte
        M = Dot([0, -1.5, 0], color=TXTCOL)
        A = Dot([-r, 0, 0] + M.get_center(), color=TXTCOL)
        B = Dot([r, 0, 0] + M.get_center(), color=TXTCOL)
        S = Dot([-1.3, 0, 0] + M.get_center(), color=TXTCOL)
        N = Dot([0,r,0] + M.get_center(), color=TXTCOL)
        cord = M.get_y() + math.sqrt(r**2-(S.get_x())**2)
        X = Dot([S.get_x(), cord, 0], color=TXTCOL)

        # Linienundso
        sega = Line(start=A.get_center(), end=S.get_center(), color=TXTCOL)
        segb = Line(start=S.get_center(), end=B.get_center(), color=TXTCOL)
        semikreis = Arc(radius=r, start_angle=0, angle=PI, arc_center=M.get_center(), color=TXTCOL)
        gm = Line(S,X, color=GMCOL)
        am1 = Line(M,X, color=AMCOL)
        am2 = Line(M,N, color=AMCOL)
        am3 = Line(M,A, color=AMCOL)
        qm = Line(S,N, color=QMCOL)
        G = Dot(am1.get_projection(S.get_center()), color=TXTCOL)
        hm = Line(X,G, color=HMCOL)
        lineAX = Line(A.get_center(),X.get_center(), color=TXTCOL)
        lineBX = Line(B.get_center(),X.get_center(), color= TXTCOL)
        lineMS = Line(M,S, color=TXTCOL)
        dashed1 = DashedLine(S.get_center(),G.get_center(), color=TXTCOL, stroke_width=3)
        dashedam = DashedLine(M.get_center(),X.get_center(), color=AMCOL, stroke_width=2)

        # Labels
        labelM = MathTex("M", font_size=24, color=TXTCOL)
        labelM.next_to(M, UR, buff=0.05)
        labelS = MathTex("S", font_size=24, color=TXTCOL)
        labelS.next_to(S, UL, buff=0.05)
        labelN = MathTex("N", font_size=24, color=TXTCOL)
        labelN.next_to(N, UL, buff=0.05)
        labelX = MathTex("X", font_size=24, color=TXTCOL)
        labelX.next_to(X, UL, buff=0.05)
        labelG = MathTex("G", font_size=24, color=TXTCOL)
        labelG.next_to(G, UR, buff=0.05)

        # nur zum animieren
        firsta = Line(A.get_center() + [-0.25, 0.5, 0],
                      S.get_center() + [-0.25, 0.5, 0], color=TXTCOL)
        firstb = Line(S.get_center() + [0.25, 0.5, 0],
                      B.get_center() + [0.25, 0.5, 0], color=TXTCOL)

        

        # Braces
        b1 = Brace(firsta, direction=firsta.copy().rotate(PI / 2).get_unit_vector(), color=TXTCOL)
        b2 = Brace(firstb, direction=firstb.copy().rotate(PI / 2).get_unit_vector(), color=TXTCOL)
        b1text = b1.get_tex("a")
        b1text.set_color(TXTCOL)
        b2text = b2.get_tex("b")
        b2text.set_color(TXTCOL)
        labelAB = VGroup(b1text, b2text)
        abr = Brace(sega, direction=firsta.copy().rotate(3*PI / 2).get_unit_vector(), color=TXTCOL)
        bbr = Brace(segb, direction=firstb.copy().rotate(3*PI / 2).get_unit_vector(), color=TXTCOL)
        abrtxt = abr.get_tex("a")
        abrtxt.set_color(TXTCOL)
        bbrtxt = bbr.get_tex("b")
        bbrtxt.set_color(TXTCOL)

        

        #Winkel
        rightAXB = Angle(Line(X,A), Line(X,B), radius=0.5, other_angle=False, dot=True, dot_color=RIGHTANGLECOL, color=RIGHTANGLECOL)
        #rightAXBdot = Dot((2*rightAXB.get_center() + X.get_center())/3, color=RIGHTANGLECOL)
        rightS = Angle(Line(S,M), Line(S,X), radius=0.3, other_angle=False, dot=True, dot_color=RIGHTANGLECOL, color=RIGHTANGLECOL)
        #rightSdot = Dot((4*rightS.get_center() + S.get_center())/5, color=RIGHTANGLECOL, radius=0.05)
        rightM = Angle(Line(M,N), Line(M,S), radius=0.3, other_angle=False, dot=True, dot_color=RIGHTANGLECOL, color=RIGHTANGLECOL)
        #rightMdot = Dot((4*rightM.get_center() + M.get_center())/5, color=RIGHTANGLECOL, radius=0.05)
        rightG = Angle(Line(G.get_center(),S.get_center()), Line(G.get_center(),X.get_center()), radius=0.3, other_angle=True, dot=True, dot_color=RIGHTANGLECOL, color=RIGHTANGLECOL)
        #rightGdot = Dot((4*rightG.get_center() + G.get_center())/5, color=RIGHTANGLECOL, radius=0.05)
        angleX = Angle(Line(X,S),Line(X,M), radius=0.5, color = PINK, stroke_width=3)
        angleXlabel = MathTex(r"\alpha", color=PINK, font_size=24).move_to(
            Angle(
                Line(X,S),Line(X,M), radius=0.5 + 3 * SMALL_BUFF
            ).point_from_proportion(0.5)
        )

        
        

        #Dreiecke und Grops
        QMAMDreieck = Group(qm, am2, lineMS, S, M, N, rightM)
        AMGMDreieck = Group(gm, am1, lineMS, S, M, X, rightS) #auch Dreieck für Ähnlichkeit
        GMHMDreieck = Group(hm, gm, dashed1, S, G, X, rightG)
        angXl = Group(angleX, angleXlabel)
        GanzeSkizze = VGroup(
        #    Punkte
        M, A, B, S, N, X, G,

        # Linien
        sega, segb, semikreis, gm, am1, am2, am3, qm,
        hm, lineAX, lineBX, lineMS, dashed1, dashedam,

        # Labels
        labelM, labelS, labelN, labelX, labelG,

        # nur zum animieren
        firsta, firstb,

        # Braces + brace texts
        b1, b2, b1text, b2text, labelAB,
        abr, bbr, abrtxt, bbrtxt,

        # Winkel + Winkel-Labels
        rightAXB, rightS, rightM, rightG,
        angleX, angleXlabel
        )


        

        # Konstruktion Kreis + AM
        self.play(FadeIn(firsta), FadeIn(firstb), FadeIn(b1), FadeIn(labelAB), FadeIn(b2))
        term1 = MathTex(r"a + b", color=TXTCOL).shift(UP*3)
        self.play(Transform(firsta, sega), FadeOut(b1), FadeOut(b2), TransformMatchingShapes(labelAB, term1), Transform(firstb, segb))
        term2 = MathTex(r"\frac{a + b}{2}", color=TXTCOL).shift(UP*3)
        self.play(Create(S), FadeIn(abr), FadeIn(bbr), FadeIn(abrtxt), FadeIn(bbrtxt))
        self.play(Create(M), Create(labelM), TransformMatchingShapes(term1, term2))
        self.play(Create(semikreis))
        term3 = MathTex(r"r =", r"\frac{a + b}{2}", r"= AM(a,b)", color=AMCOL).shift(UP*3)
        term2.generate_target()
        term2.target.move_to(term3[1].get_center())  # move into place
        term2.target.set_color(AMCOL) 
        self.play(
            MoveToTarget(term2),  # morph fraction to new fraction
            FadeIn(term3[0]),  # r =
            FadeIn(term3[2])   # = AM(a,b)
        )
        #bitte bite funktuniertre
        moving_dot = Dot(semikreis.point_from_proportion(0), color=RED)
        moving_dot.set_opacity(0)
        line = always_redraw(lambda: Line(M.get_center(), moving_dot.get_center(), color=AMCOL))
        self.add(moving_dot)
        self.add(line)
        self.play(
            MoveAlongPath(moving_dot,semikreis,rate_func=lambda t: 1 - (1-t)**2, run_time=3)
        )
        self.remove(line)
        self.play(Create(labelS))
        self.wait(1)
        self.play(FadeOut(term3),FadeOut(term2))

        #qm visualisieren
        #vorbereitung
        self.add(lineMS)
        tex1 = MathTex(r"QM(a,b) = \sqrt{\frac{a^2+b^2}{2}}", color = QMCOL).shift(UP*3)
        self.play(Write(tex1))
        self.play(FadeIn(am2), FadeIn(N))
        self.play(Create(qm))
        self.play(Create(labelN))
        self.play(Create(rightM))
        self.play(Wiggle(QMAMDreieck))
        self.play(ApplyMethod(GanzeSkizze.shift, LEFT*3))
        term10 = MathTex(r"{{\frac{a+b}{2}}}", color = TXTCOL).shift(UP*3)
        term11 = MathTex(r"\frac{a+b}{2} - a", color = TXTCOL).shift(UP*3)
        term12 = MathTex(r"{{\frac{b-a}{2}}}", color = TXTCOL).shift(UP*3)
        term13 = MathTex(r"|\overline{SM}| = ({{\frac{b-a}{2}}})^2 + ({{\frac{b-a}{2}}})^2 ", color = TXTCOL).shift(UP*3)
        self.play(FadeIn(am3), run_time=0.5)
        self.play(Wiggle(am2))
        self.remove(lineMS)
        lineMS.color = RED
        self.play(ReplacementTransform(am3,lineMS)) 
        self.play(Wiggle(lineMS))
        self.play(lineMS.animate.set_color(TXTCOL))


        #gm visualisierung
        term4 = MathTex(r"a \cdot b", color=TXTCOL).shift(UP*3)
        term5 = MathTex(r"\sqrt{ab}", color=TXTCOL).shift(UP*3)
        term6 = MathTex(r"GM(a,b) =", r"\sqrt{ab}", color=GMCOL).shift(UP*3)
        term5.generate_target()
        term5.target.move_to(term6[1].get_center())  # move into place
        term5.target.set_color(GMCOL) 
        self.play(Write(term4))
        self.play(TransformMatchingShapes(term4, term5))
        self.play(FadeIn(term6[0]), MoveToTarget(term5))
        self.wait(1)
        self.play(FadeOut(term6), FadeOut(term5))
        self.play(Create(gm), Create(rightS))
        self.play(Create(X))
        self.play(Create(labelX))
        self.play(AnimationGroup(Create(lineAX), Create(lineBX)))
        self.play(AnimationGroup(Create(rightAXB)))
        term7 = MathTex(r"{{|\overline{SX}|}}", r"^2 {{=}}", r"{{a}} \cdot", r"{{b}}", color=TXTCOL).shift(UP*3)
        self.play(Write(term7[0]), Wiggle(gm))
        self.play(Write(term7[1]), Wiggle(gm))
        self.play(Write(term7[2]), Wiggle(sega))
        self.play(Write(term7[3]), Wiggle(segb))
        self.wait(1)
        term8 = MathTex(r"{{|\overline{SX}|}} {{=}} \sqrt{{{a}}{{b}}}", color = TXTCOL).shift(UP*3)
        term9 = MathTex(r"|\overline{SX}| = \sqrt{ab}", r"= GM(a,b)", color = GMCOL).shift(UP*3)
        self.play(TransformMatchingTex(term7,term8))
        term8.generate_target()
        term8.target.move_to(term9[0].get_center())  # move into place
        term8.target.set_color(GMCOL) 
        self.play(FadeIn(term9[1]), MoveToTarget(term8))
        self.wait(1)
        self.play(FadeOut(term8), FadeOut(term9), FadeOut(lineAX), FadeOut(lineBX), FadeOut(rightAXB))

        self.play(ReplacementTransform(am2,am1))
        self.wait(1)


        #hm visualisieren
        self.play(ReplacementTransform(am1,dashedam))
        self.play(Create(dashed1))
        self.play(Create(G), Create(labelG))
        self.play(Create(hm), Create(rightG))
        self.play(Create(angleX), Create(angleXlabel))
        self.play(Wiggle(angXl))
        self.play(Wiggle(rightG), Wiggle(rightS))
        self.play(Wiggle(AMGMDreieck))
        self.play(Wiggle(GMHMDreieck))


        self.wait(1)

        


